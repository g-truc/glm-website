<?xml version="1.0" encoding="iso-8859-1" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>OpenGL Mathematics</title><meta content="en" http-equiv="Content-Language" /><meta content="application/xhtml+xml; charset=iso-8859-1" http-equiv="Content-Type" /><meta content="G-Truc Creation" name="copyright" /><link type="text/css" media="screen, print, embossed" rel="stylesheet" href="../common/style.css" /><link type="text/css" media="screen, print, embossed" rel="stylesheet" href="../common/code.css" /><script type="text/javascript">
				var _gaq = _gaq || [];
				_gaq.push(['_setAccount', 'UA-20182250-1']);
				_gaq.push(['_setDomainName', '.g-truc.net']);
				_gaq.push(['_trackPageview']);

				(function() 
				{
					var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
					ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
					var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
				})();
			</script></head><body><div class="root"><div class="version"><div><a class="active" href="http://glm.g-truc.net">GLM</a> <a href="http://gli.g-truc.net">GLI</a> </div><a href="../0.9.8/index.html" class="active">0.9.8</a> <a href="../0.9.7/index.html">0.9.7</a> <a href="../0.9.6/index.html">0.9.6</a> <a href="../0.9.5/index.html">0.9.5</a> <a href="../0.9.4/index.html">0.9.4</a> <a href="../0.9.3/index.html">0.9.3</a> <a href="../0.9.2/index.html">0.9.2</a> <a href="../0.9.1/index.html">0.9.1</a> <a href="../0.9.0/index.html">0.9.0</a> </div><table><tr><td class="menu"><div class="menu"><div class="menu-logo"><a href="./index.html"><img alt="Logo" src="../common/logo.png" class="menu-img" /></a></div><div class="menu-entry1"><a href="https://github.com/g-truc/glm/releases/download/0.9.8.4/glm-0.9.8.4.zip" class="menu"><div>Download GLM 0.9.8.4</div><div>2017-01-22</div></a></div><div class="menu-entry1"><div class="menu-entry2"><a class="menu" href="../0.9.8/glm-0.9.8.pdf">Manual</a></div><div class="menu-entry2"><a class="menu" href="../0.9.8/api/index.html">API Documentation</a></div></div><div class="menu-entry1"><div class="menu-entry2"><a class="menu" href="https://github.com/g-truc/glm/releases">Release Notes</a></div><div class="menu-entry2"><a class="menu" href="https://github.com/g-truc/glm/tags">Downloads</a></div><div class="menu-entry2"><a class="menu" href="https://github.com/g-truc/glm/issues">Report Bug</a></div></div><div class="menu-entry1"><div class="menu-entry2"><a class="menu" href="https://github.com/g-truc/glm">Repository</a></div><div class="menu-entry2"><a class="menu" href="https://github.com/g-truc/glm/archive/master.zip">Code Snapshot</a></div><div class="menu-entry2"><a href="https://travis-ci.org/g-truc/glm"><img alt="Build Status" src="https://travis-ci.org/g-truc/glm.svg?branch=master" class="menu-img" /></a></div></div><div class="menu-entry1"><div class="menu-entry2"><a class="menu" href="http://stackoverflow.com/search?q=GLM">Stack Overflow</a></div><div class="menu-entry2"><a class="menu" href="https://www.opengl.org/registry/doc/GLSLangSpec.4.50.diff.pdf">GLSL Specification</a></div><div class="menu-entry2"><a class="menu" href="http://www.opengl.org/documentation/glsl">GLSL Man Pages</a></div><div class="menu-entry2"><a class="menu" href="http://www.opengl.org/wiki/Data_Type_%28GLSL%29">GLSL Data Types</a></div></div><br /><div><a href="https://twitter.com/g_truc"><img alt="RSS" src="../twitter.png" class="menu-img" /></a></div><br /><div><a href="../feed.rss"><img alt="RSS" src="../rss.png" class="menu-img" /></a></div><br /><br /><div><a href="http://www.g-truc.net"><img alt="G-Truc Creation" src="../common/g-truc.jpg" class="menu-img" /></a></div></div></td><td class="page"><h3>Code samples</h3><span class="code-title">Compute a triangle normal:</span><ul class="code-list"><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/vec3.hpp&gt;</span><span class="comment">// glm::vec3</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/geometric.hpp&gt;</span><span class="comment">// glm::cross, glm::normalize</span></span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content"><span class="keyword">void </span> computeNormal(triangle &amp; Triangle)
		</span></li><li class="code-line"><span class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec3 </span><span class="keyword">const </span> &amp; a = Triangle.Position[0];
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec3 </span><span class="keyword">const </span> &amp; b = Triangle.Position[1];
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec3 </span><span class="keyword">const </span> &amp; c = Triangle.Position[2];
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			Triangle.Normal = glm::normalize(glm::cross(c - a, b - a));
		</span></li><li class="code-line"><span class="code-line-content">
			}
		</span></li></ul><span class="code-title">Matrix transform:</span><ul class="code-list"><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/vec3.hpp&gt; </span><span class="comment">// glm::vec3</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/vec4.hpp&gt; </span><span class="comment">// glm::vec4, glm::ivec4</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/mat4x4.hpp&gt; </span><span class="comment">// glm::mat4</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/gtc/matrix_transform.hpp&gt; </span><span class="comment">// glm::translate, glm::rotate, glm::scale, glm::perspective</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/gtc/type_ptr.hpp&gt; </span><span class="comment">// glm::value_ptr</span></span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content"><span class="keyword">void</span> func(GLuint LocationMVP, float Translate, glm::vec2 const &amp; Rotate)
		</span></li><li class="code-line"><span class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">mat4</span> Projection = glm::perspective(glm::radians(45.0f), 4.0f / 3.0f, 0.1f, 100.f);
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">mat4</span> ViewTranslate = glm::translate(glm::<span class="userword">mat4</span>(1.0f), glm::<span class="userword">vec3</span>(0.0f, 0.0f, -Translate));
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">mat4</span> ViewRotateX = glm::rotate(ViewTranslate, Rotate.y, glm::<span class="userword">vec3</span>(-1.0f, 0.0f, 0.0f));
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">mat4</span> View = glm::rotate(ViewRotateX, Rotate.x, glm::<span class="userword">vec3</span>(0.0f, 1.0f, 0.0f));
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">mat4</span> Model = glm::scale(glm::<span class="userword">mat4</span>(1.0f), glm::<span class="userword">vec3</span>(0.5f));
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">mat4</span> MVP = Projection * View * Model;
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glUniformMatrix4fv(LocationMVP, 1, GL_FALSE, glm::value_ptr(MVP));
		</span></li><li class="code-line"><span class="code-line-content">
			}
		</span></li></ul><span class="code-title">Vector types:</span><ul class="code-list"><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/vec2.hpp&gt;</span><span class="comment">// glm::vec2</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/packing.hpp&gt;</span><span class="comment">// glm::packUnorm2x16</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/integer.hpp&gt;</span><span class="comment">// glm::uint</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/gtc/type_precision.hpp&gt;</span><span class="comment">// glm::i8vec2, glm::i32vec2</span></span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content">
			std::size_t <span class="keyword">const </span>VertexCount = 4;
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content"><span class="comment">// Float quad geometry</span></span></li><li class="code-line"><span class="code-line-content">
			std::size_t <span class="keyword">const </span>PositionSizeF32 = VertexCount * <span class="keyword">sizeof</span>(glm::<span class="userword">vec2</span>);
		</span></li><li class="code-line"><span class="code-line-content">
			glm::<span class="userword">vec2 </span><span class="keyword">const </span>PositionDataF32[VertexCount] =
		</span></li><li class="code-line"><span class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec2</span>(-1.0f,-1.0f),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec2</span>( 1.0f,-1.0f),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec2</span>( 1.0f, 1.0f),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec2</span>(-1.0f, 1.0f)
		</span></li><li class="code-line"><span class="code-line-content">
			};
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content"><span class="comment">// Half-float quad geometry</span></span></li><li class="code-line"><span class="code-line-content">
			std::size_t <span class="keyword">const </span>PositionSizeF16 = VertexCount * <span class="keyword">sizeof</span>(glm::<span class="userword">uint</span>);
		</span></li><li class="code-line"><span class="code-line-content">
			glm::<span class="userword">uint </span><span class="keyword">const </span>PositionDataF16[VertexCount] =
		</span></li><li class="code-line"><span class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">uint</span>(glm::packUnorm2x16(glm::vec2(-1.0f, -1.0f))),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">uint</span>(glm::packUnorm2x16(glm::vec2( 1.0f, -1.0f)),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">uint</span>(glm::packUnorm2x16(glm::vec2( 1.0f,  1.0f))),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">uint</span>(glm::packUnorm2x16(glm::vec2(-1.0f,  1.0f)))
		</span></li><li class="code-line"><span class="code-line-content">
			};
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content"><span class="comment">// 8 bits signed integer quad geometry</span></span></li><li class="code-line"><span class="code-line-content">
			std::size_t <span class="keyword">const </span>PositionSizeI8 = VertexCount * <span class="keyword">sizeof</span>(glm::<span class="userword">i8vec2</span>);
		</span></li><li class="code-line"><span class="code-line-content">
			glm::<span class="userword">i8vec2 </span><span class="keyword">const </span> PositionDataI8[VertexCount] =
		</span></li><li class="code-line"><span class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i8vec2</span>(-1,-1),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i8vec2</span>( 1,-1),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i8vec2</span>( 1, 1),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i8vec2</span>(-1, 1)
		</span></li><li class="code-line"><span class="code-line-content">
			};
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content"><span class="comment">// 32 bits signed integer quad geometry</span></span></li><li class="code-line"><span class="code-line-content">
			std::size_t <span class="keyword">const </span>PositionSizeI32 = VertexCount * <span class="keyword">sizeof</span>(glm::<span class="userword">i32vec2</span>);
		</span></li><li class="code-line"><span class="code-line-content">
			glm::<span class="userword">i32vec2 </span><span class="keyword">const </span>PositionDataI32[VertexCount] =
		</span></li><li class="code-line"><span class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i32vec2 </span>(-1,-1),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i32vec2 </span>( 1,-1),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i32vec2 </span>( 1, 1),
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">i32vec2 </span>(-1, 1)
		</span></li><li class="code-line"><span class="code-line-content">
			};
		</span></li></ul><span class="code-title">Lighting:</span><ul class="code-list"><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/vec3.hpp&gt;</span><span class="comment">// glm::vec3</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/geometric.hpp&gt;</span><span class="comment">// glm::normalize, glm::dot, glm::reflect</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/exponential.hpp&gt;</span><span class="comment">// glm::pow</span></span></li><li class="code-line"><span class="code-line-content"><span class="keyword">#include </span><span class="string">&lt;glm/gtc/random.hpp&gt;</span><span class="comment">// glm::vecRand3</span></span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span class="code-line-content">
			glm::<span class="userword">vec3 </span> lighting
		</span></li><li class="code-line"><span class="code-line-content">
			(
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			intersection<span class="keyword"> const </span>&amp; Intersection,
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			material<span class="keyword"> const </span>&amp; Material,
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			light<span class="keyword"> const </span>&amp; Light,
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec3 </span>const &amp; View
		</span></li><li class="code-line"><span class="code-line-content">
			)
		</span></li><li class="code-line"><span class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec3 </span> Color(0.0f);
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			glm::<span class="userword">vec3 </span>LightVector(glm::normalize(
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content">
			Light.position() - Intersection.globalPosition() +
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content">
			glm::vecRand3(0.0f, Light.inaccuracy()));
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span style="padding-left:32px" class="code-line-content"><span class="keyword">if</span>(!shadow(Intersection.globalPosition(), Light.position(), LightVector))
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content"><span class="keyword">float</span> Diffuse = glm::dot(Intersection.normal(), LightVector);
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content" /></li><li class="code-line"><span style="padding-left:64px" class="code-line-content"><span class="keyword">if</span>(Diffuse &lt;= 0.0f)
		</span></li><li class="code-line"><span style="padding-left:96px" class="code-line-content"><span class="keyword">return</span> Color;
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content"><span class="keyword">if</span>(Material.isDiffuse())
		</span></li><li class="code-line"><span style="padding-left:96px" class="code-line-content">
			Color += Light.color() * Material.diffuse() * Diffuse;
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content" /></li><li class="code-line"><span style="padding-left:64px" class="code-line-content"><span class="keyword">if</span>(Material.isSpecular())
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content">
			{
		</span></li><li class="code-line"><span style="padding-left:96px" class="code-line-content">
			glm::<span class="userword">vec3 </span>Reflect(glm::reflect(
		</span></li><li class="code-line"><span style="padding-left:128px" class="code-line-content">
			glm::normalize(-LightVector),
		</span></li><li class="code-line"><span style="padding-left:128px" class="code-line-content">
			glm::normalize(Intersection.normal())));
		</span></li><li class="code-line"><span style="padding-left:96px" class="code-line-content"><span class="keyword">float</span> Dot = glm::dot(Reflect, View);
		</span></li><li class="code-line"><span style="padding-left:96px" class="code-line-content"><span class="keyword">float</span> Base = Dot &gt; 0.0f ? Dot : 0.0f;
		</span></li><li class="code-line"><span style="padding-left:96px" class="code-line-content"><span class="keyword">float</span> Specular = glm::pow(Base, Material.exponent());
		</span></li><li class="code-line"><span style="padding-left:96px" class="code-line-content">
			Color += Material.specular() * Specular;
		</span></li><li class="code-line"><span style="padding-left:64px" class="code-line-content">
			}
		</span></li><li class="code-line"><span style="padding-left:32px" class="code-line-content">
			}
		</span></li><li class="code-line"><span class="code-line-content" /></li><li class="code-line"><span style="padding-left:32px" class="code-line-content"><span class="keyword">return</span> Color;
		</span></li><li class="code-line"><span class="code-line-content">
			}
		</span></li></ul></td></tr></table></div></body></html>